#include <iostream>
#include <algorithm>
#include <vector>
#include <array>
using std::cout;
using std::endl;

int main()
{

    // Недостатки указателей;
    // Указатели могут быть неинициализированными (некорректный код)
    // Указатель может быть ненулевым (корректный код), а значит указатель нужно проверять на р-во нулю
    // Аккуратно с арифметикой;
    // Тяжело отследить жизнь указателей;

    // указатели и ссылки

    // не может быть неинициализированной;
    int *p;
    // int &l; // error

    // У ссылки не нулевого значения;
    int *p = 0; // OK
    // int &l = 0; // error

    // ссылку нельзя переприсвоить;

    int a = 10, b = 20;
    int *p = &a; // p указывает на a
    p = &b;      // p указывает b;
    // int *l = a; // l ссылается на a;
    // l = b; // a присваивается значение b

    // Нельзя получить адрес ссылки или ссылку на ссылку сделать;

    // // ссылки не предполагают арифметики
    int a = 10;
    int *p = &a;   // p указывает на a
    int p = a;     // p указывает на a
    int **pp = &p; // pp указывает на переменную p
    int &l = a;    // l ссылается на a
    // int *pl = &l; // pl указывает на переменную a
    // int &&ll = l; // ошибка

    // int *mp[10] = {};
    // int &ml[10] = {};

    // для ссылок нет арифметики;

    // rvalue, lvalue

    // lvalue => слева от знака равенства можно взять адрес;
    // rvalue => временное значение, соответствующее промежуточному вычислению

    // int a = 10, b = 20;

    // int m[10] = {1, 2, 3, 4, 5};

    // int &l1 = a; // OK // ссылка на целочисленную переменную
    // // int &l2 = a + b; // Error // временное значение в памяти, поэтому эррор
    // int &l3 = *(m + a / 2);
    // // int &l4 = *(m + a / 2) + 1; // Error
    // int &l5 = (a + b > 2) ? a : b; // OK

    // Это все происходило на стэке;
    // Указатели – память в куче;

    // Зачем нужна динамическая память?
    // Стек программы ограничен. Он не предназначен для хранения больших данных;
    // не умещается на стэк

    // int main()
    // {
    //     // double m[100000000] = {}; // 80 Mb
    //     // segmentation fall
    //     return 0;
    // }

    // Время жизни локальных переменных ограничено временем работы функции.
    // Динамическая память выделяется в сегменте данных
    // Структура, отвечающая за выделение доп. памяти – куча
    // Выделение и освобождение памяти управляются вручную

    // Выделение памяти в стиле С

    // cstdlib предоставляет 4 функции управления памятью:
    void *malloc(size_t s);                  // не меньше, чем попрошено, но может больше
    void *calloc(size_t nmemb, size_t size); // заполняет нулями
    void *realloc(void *ptr, size_t size);
    void free(void *ptr);

    // size_t – специальный целочисленный
    // беззнаковый тип, вмещает размер любого типа в байтах

    // size_t используется для указания размеров типов данных,
    // для индексации массивов и пр.

    // void * - это указатель на нетипизированную память
    // (раньше для этого использовалось сhar *).

    // 2^32
    // 2^64
    // количество адресов для регистров;

    // malloc – выделяет область памяти размера >= size. Данные не инициализируются.
    // calloc – выделяет массив из nmemb элементов размера size. Данные инициализируются нулем.
    // realloc – изменяется размер области памяти по указателю ptr на size (если возможно, то это делается на месте)
    // free – освобождает область памяти, ранее выделенную одной из функции malloc / calloc / realloc
}

int main()
{
    std::cout << sizeof(void *); // 8 bytes
    int *m = (int *)malloc(1000 * sizeof(int));
    // malloc returns void * (делаем приведение int *)
    m[10] = 10;

    // изменение размера массива до 2000
    m = (int *)realloc(m, 2000 * sizeof(int));

    free(m);

    m = (int *)calloc(3000, sizeof(int)); // очищает память;
    free(m);
    m = 0;
}

// выделение памяти в стиле с++

// два набора операторов для выделения
// 1. new и delete – для одиночных значений;
// new [] delete [] for массивов

// выделение памяти под int со значением 5

int main()
{
    int *m = new int(5);
    delete m; // освобождение

    // создание массива нулей
    m = new int[1000](); // () означает обнуление
    delete[] m;          // вызывает деструктор;
    return 0;
}

// new calls constructor (в случае int тривально)
// delete calls destructor

// typical problems while working with memory

// создание переменной на стеке намного дешевле выделения для нее дин. памяти;
// проблема фрагментации: выделение большого кол-ва небольших сегментов способствует фрагментации памяти;

// утечки памяти:
int main1()
{
    // создание массива из 1000 int;
    int *m = new int[1000];

    // создание массива из 2000 int;
    m = new int[2000]; // утечка памяти;
    delete[] m;        // удалили массив на 2000, на 1000 не удалили;
    // не вызван delete [] m, утечка памяти;

    // переставлять выделенные ячейки нельзя;

    // на новый new нужно искать;
    return 0;
}

// Проблемы при работе с памятью;

int main3()
{
    int *m1 = new int[1000];
    delete m1; // должно быть delete [] m1 // утечка

    int *p = new int(0);
    free(p); // совмещение С++ и C
    free(p); // двойное удаление – утечка

    int *q2 = (int *)malloc(sizeof(int));
    free(q2);
    q2 = 0;   // обнуляем указатель
    free(q2); // правильно работает для q2=0
}

// Многомерные встроенные массивы;

int main()
{

    int m2d[2][3] = {{1, 2, 3}, {4, 5, 6}};
    for (size_t i = 0; i != 2; ++i)
    {
        for (size_t j = 0; j != 3; ++j)
        {
            cout << m2d[i][j] << ' ';
        }
        cout << endl;
    }
}

// элементы m2d располагаются по строчкам
// access
// размерность массивов может быть любой, но на практике редко
// используют массивы размерности > 4.

// посмотреть размер стэка -> чтобы не было хвостовой рекурсии;

// Динамические массивы

// Для выделения одномерных динам. массивов обычно используется оператор new []
// int *m1d = new int[100];

// Какой тип должен быть у указателя на двумерный динамический массив?

// Пусть m – указатель на двумерный массив типа int.
// Значит m[i][j] имеет тип int (точнее int &)

// m[i][j] <-> *(m[i] + j), т.е. тип m[i] - int *.
// аналогично, m[i] <-> *(m + i), т.е. тип m - int **.

// Чему соответствует значение m[i]?
// Это адрес строки с номером i.

// Чему соответствует значение m?
// Это адрес массива с указателями на строки.

// ???

// Двумерные массивы
void fn()
{
    int **m = new int *[5];
    for (size_t i = 0; i != 5; ++i)
    {
        m[i] = new int[4];
    }
}